ID,Content Length,Content
558811822719762452,35,<@314205761846902788> what language
558814525076275200,3,uhm
558814601651683369,55,assignment expressions were introduced in python in 3.8
558814649332662279,52,in Java 1 doesn't work as true <@314205761846902788>
558814716537864202,51,in python_ yes. in Java_ it's not a `boolean` so no
558851663041921035,2,ew
558851694969094144,6,python
558851715261005824,12,is third wtf
558851866746945536,117,i think python is misrepresented (and to an extent JS too) because they're usually the only language respondents know
558851885835091998,37,so they have nothing to compare it to
558852088206065664,76,well_ not that people know more than one language for other languages though
558852211132596234,85,but i guess it's that they have a bit of an advantage from being scripting languages?
558852400274997276,29,also ü§î rust is hard to learn?
558852913628446721,24,üò¶ aww we can't ping mods
558852984042422272,56,re: "what languages and tools they are comfortable with"
558853030074646550,62,would there need to be guidelines on what counts/doesn't count
558853458879315974,39,depending on the meaning of larger_ yes
558853511920484394,49,i haven't done larger as in multiple people large
558853627087683594,3,lol
558854101497020437,115,re: python. sure_ it isn't _bad_. but no way is it _that_ much better than literally every other scripting language
558855431162953748,17,ü§î hmm. fair point
560621397781643274,92,<@194861788926443520> not the best for working across multiple devices - cloud9 is a thing üòõ
560621511812317215,59,<@205069548595052544> i started a kinda large project at 16
560627417832488960,66,<@326422614073671681> why would the parser care about the contents
560627597294174219,132,if you mean the lexer outputting `BINARY_LITERAL` instead of the parser figuring which one it is then that's done very_ _very_ often
560628209029349396,3,uhh
560628235445207086,40,isn't that the conventional way to do it
560628325261901824,39,well some people use subclass of `Node`
560628378672300033,26,<@326422614073671681> hmm?
560628537028116481,56,<@242066553183404032> it pays off right from the start üòõ
560628709594497025,4,hmm?
560628864800260098,53,yeah normally you'd just have a terminal for `NUMBER`
560628898304491521,38,the parser does _not_ need to know how
560629175355179038,108,then wdym "The parser would care if it were looking to make sure that the token matched the production rule"
560629211027734528,1,üòê
560629481702686721,183,```NLnumber = BINARY_LITERAL {% Token(BINARY_LITERAL_ item) %}NL  | HEXADECIMAL_LITERAL {% Token(HEXADECIMAL_LITERAL_ item) %}NL  | DECIMAL_LITERAL {% Token(DECIMAL_LITERAL_ item) %}NL```
560629651391905843,69,"I tokenized all of the digits in a number." - together or separately
560629791053840384,142,what i'm saying is the parser _doesn't need to know_ what the lexer does. it's a lot easier if you just assume the lexer is behaving correctly
560630151319388188,10,of course?
560630638986788878,98,"I don't recall seeing any serious languages ever do that." - of course... it's hard to understand
560630657789853707,17,it's confusing...
560630768183934986,31,well actually... lisp does that
560631237266636830,3,...
560631292186591242,53,when would naming a variable like that ever be useful
560631324113895454,7,exactly
560631369730883594,56,which means it _shouldn't be allowed_ in the first place
560631417097420801,62,programming languages aren't designed to make your life harder
560631542888792105,31,don't really need numbers there
560631617899593779,23,`64BitInteger`... maybe
560631657967910912,60,but it's only in very rare cases that it's actually readable
560631784266661899,48,the disadvantages outweigh the advantages though
560631812901306409,33,i'm not saying that's a bad thing
560631867825455104,65,i'm just answering "So I'm wondering why that isn't more common."
